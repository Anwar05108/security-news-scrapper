Sophos Home protects every Mac and PC in your home 
Python is dead. Long live Python!
Python 2 has been one of the worldâ€™s most popular programming languages since 2000, but its death â€“ strictly speaking, at the stroke of midnight on New Yearâ€™s Day 2020 â€“ has been widely announced on technology news sites around the world.
But Python isnâ€™t dead, because Python 3 has been around since the late 2000s.
So there will be  no â€œinterregnumâ€ period during which Python doesnâ€™t exist â€“ just as in a hereditary monarchy, succession is considered technically instantaneous, ensuring an unbroken line.
If youâ€™re programmer or a sysadmin (and, in truth, a sysadmin is just a special sort of programmer who is expected to use their skills to code people out of the holes that others have coded them into), then you have almost certainly used Python at some point.
And if youâ€™ve never programmed in Python yourself, youâ€™ve almost certainly used software written in Python, or relied on online services that were supported by software written in the Python language.
So, given that Python 2 has been replaced by Python 3 without any interruption, and given that nothing bad happened when Python 1 switched over to Python 2 around the turn of the millennium, why is the â€œdeathâ€ of Python 2 such a big deal now?
Well, the problem â€“ or the perceived problem â€“ is that the changeover is not quite as straightforward this time as it was before.
When Python 2 came along, it was a natural progresion from Python 1, and software written in Python 1 was, essentially, already valid Python 2.
So you could just replace your Python 1 software development system with a Python 2 installation and carry on as usual.
However, when Python 3 was introduced, it included what software developers call breaking changes â€“ differences that were incompatible to the point that you couldnâ€™t just take a Python 2 program, run it under Python 3, and expect it to perform correctly.
Python 3 was devised, at least in part, to be different from Python 2 in carefully planned and incompatible ways.
The idea was not only to add new features to Python 3 but also to remove some of the pitfalls and imperfections that Python 2 was forced to inherit from Python 1 in order to stay compatible with it.
As the Python website says:
Python 3.0 (a.k.a. â€œPython 3000â€ or â€œPy3kâ€) is a new version of the language that is incompatible with the 2.x line of releases. The language is mostly the same, but many details, especially how built-in objects like dictionaries and strings work, have changed considerably, and a lot of deprecated features have finally been removed. Also, the standard library has been reorganized in a few prominent places.
Thatâ€™s usually the whole idea of breaking changes in programming â€“ you do them not because you want to break the software in the future, and thereby to make things worse, but to break with some of the mistakes you made in the past, and thereby to make things better in the long run.
Thatâ€™s why Python 2 and Python 3 have coexisted for so many years â€“ to give programmers plenty of time to port their code to Python 3, ready for the end of the Python 2 era.
In an ideal world, the Python ecosystem â€“ remember, Python is a free and open-source project, not a commercial venture â€“ would simply carry on supporting Python 2 for everâ€¦
â€¦but that would eat up an enormous amount of time, most of it given voluntarily by Python fans around the world.
Plus, the Python community devised Python 3 to be better than Python 2, and to remove some of its risky, confusing and unnecessary parts.
Indeed, all that time-consuming work â€œbackportingâ€ new fixes to the old codebase would ironically make it easier for die-hard Python 2 fans to keep on living in the past.
Python 2 software will still work, so thereâ€™s no immediate problem â€“ the â€œdeathâ€ of Python 2 is a conceptual issue, not a literal one.
In other words, if you still have large Python 2 projects that you havenâ€™t yet ported to Python 3, youâ€™re not in imminent danger of your software stopping working.
But the entire Python 2 environment will no longer be getting security fixes, making it a bit of a foolâ€™s errand to carry on using it. 
As the Python Foundationâ€™s news blog explains:
Users are urged to migrate to Python 3 to benefit from its many improvements, as well as to avoid potential security vulnerabilities in Python 2.x after April 2020. This move will free limited resources for the CPython core developer community for other important work.
So, we recommend:
As an interesting aside, even though 01 January 2020 is the official â€œdeath of Python 2â€ date, youâ€™ll have noticed the mention of â€œApril 2020â€ in the Python Foundationâ€™s comments above.
Indeed, it seems that CPython (the primary Python implementation, itself written in C) will actually see its last major version in April 2020, after which â€œall [CPython] development will cease for Python 2.â€
So perhaps Python 2 isnâ€™t quite dead after allâ€¦
â€¦perhaps itâ€™s just resting; maybe pining for the fjords?
Follow @NakedSecurity on Twitter for the latest computer security news.
Follow @NakedSecurity on Instagram for exclusive pics, gifs, vids and LOLs!
Thanks for posting this Duck.  As a sysadmin I shouldâ€™ve been aware of this but wasnâ€™t.
Off the top of my head I can only think of Denyhosts using Python, which I see updated in October to keep pace with this.  
Of course after OpenSSH stopped supporting TCP wrappers, Iâ€™d expect DenyHosts lost some implementations to Fail2Ban.  My legacy DH instances trigger external scripts instead of relying on hosts.deny, so I dodged that prior bulletâ€“only to eventually find myself in the path of this one.
:,)
Awsome
I got laughed at by python folks for using PHP. Whoâ€™s laughing now? Me. Iâ€™m laughing
PHP isnâ€™t immune to breaking changes between major versions, either. 
As explained above, itâ€™s hard to improve a language if you can never eradicate any poor decisions from the past.
For example, if moving from PHP 5.6 to PHP 7:
https://www.php.net/manual/en/migration70.incompatible.php
I had a PHP application live for ~13 years before seeing retirement, requiring only one global search and replace for â€œmysql_â€ â†’ â€œmysqli_â€ that once.  â€œBreaking changes between versionsâ€ are often things developers shouldnâ€™t have been utilizing anyway going away for good reasons.  Thatâ€™s less of an issue than not regression, thatâ€™s easy, but subtle persistence: https://www.php.net/parse_str â€” finally deprecated as of 7.2, and there are some who promoted register_globals use to its death, and beyond the grave, writing work-alike implementations of a terrible idea.
But I have 12x as many Python applications deployed in the same timescale as one PHP application if I wish to achieve this level of quality.  (Iâ€™m talking: maybe eight hours of downtimeâ€¦ in 2013â€¦ during its lifetime.)
Click bait title. The transition from python 2 to python 3 has been ongoing for quite some time now.
Itâ€™s almost as though you didnâ€™t read the article :-)
The transition to Python 3 was announced in 2014 (https://www.python.org/doc/sunset-python-2/). Thereâ€™s been plenty of â€œItâ€™s time to goâ€ articles, blog posts, and conference discussions since then. 
If you havenâ€™t upgraded by now, youâ€™re in the Windows XP camp, and youâ€™ve no-one to blame but yourselves. Get moving.
I *almost* mentioned XP in the article but figured that it might come across as a *bit* too acerbic :-)
But itâ€™s a useful analogy â€“ we all had plennnnnnnnty of warning!
â€œX is dead, long live Xâ€ dur hur look at me being an original writer! Dur hur look at me, look at me!
Infuriating.
Otherwise, good article.
Well, thanks for the comment. More or less.
Sarcasm is dead!  Long live sarcasm!
When will OS vendors stop shipping python 2?
I guess once this happens, most of the community will be naturally moving out of python2 ğŸ™‚
Thatâ€™s a good questionâ€¦
â€¦I guess one problem is that lots of server-side Python code runs on Linux, and the modern trend is for distros to ship with comparaively few â€œstandard packagesâ€, and to rely on users, sysadmins and apps just fetching the bits and pieces they need as they need them (sometimes automatically). That, and the fact that you can fairly easily roll up a Python app into a standalone bundle that includes everything it needs to launch, including its own copy of the Python interpreter and the needed libraries. (That way your app runs even if there is no Python installed on the destination computer at all.)
Python 2 still comes with MacOs Catalina, so even though it displays a warning that it will be removed from future versions of MacOs, it seems likely Apple will continue to support it until EOL of Catalina.  This implies theyâ€™ll be patching it if needed.  Weâ€™ll have to wait and see.
Weâ€™ve had plenty of time to move our code over, theyâ€™ve also had plenty of time to fix all the bugs e.g. https://stackoverflow.com/questions/53254622/zipfile-header-language-encoding-bit-set-differently-between-python2-and-python3
Some of my code wonâ€™t be moving just yet.
I agree, except for the tricky bit where you refer to fixing â€œall the bugsâ€â€¦ as Windows XP users frequently find, some bugs that get discovered by researchers poking sticks at modern versions of Windows turn out to work on older versions of Windows, too.
Point taken, let me change that from â€˜all the bugsâ€™ to â€œI just want to be able to unpack a zip archive and re-pack it so it has the same checksum afterwardsâ€ which you canâ€™t do in Python 3, but can in Python 2 :D.
If you want to unpack and archive and repack it exactlyâ€¦
â€¦then the best way is NOT to repack it. Unpack and examine it. If you accept it in that form, why repack it? Use the original file. 
(If you are using the unpack-and-repack approach as a cheap-and-cheerful way of validating the archive, I suggest a more rigorous approach instead.)
Why repack?  Hereâ€™s one reason:  Take a zip file known to include many duplicate files, unpack it to remove the duplicates send over the network as a stream of data + metadata describing said duplicates and as a result use a fraction of the bandwidth to transmit it, re-pack at the other end.  With such an operation Iâ€™d want the checksum to remain unchanged.
Did you figure out what changed? Did you create the original file with exactly the same zip library code, compiled in exactly the same way? Or are two slightly different builds of the compressor being used?
Paul, itâ€™s not my code, itâ€™s this line in the zipfile module thatâ€™s doing it: https://github.com/python/cpython/blob/master/Lib/zipfile.py#L1578 (zinfo.flag_bits = 0x00 in case the line number in that reference changes) it forces to zero one of the zipinfo header fields regardless of whatâ€™s passed into the method, meaning round-trip decompress -> compress may give a different file content.  There is no such line in the equivalent Python 2 module.
If it matters to you (and there is no obvious â€œbug fixâ€ reason for setting flag_bits to 0), then one fix is to write a post-processor that parses its way through the zipfile itself and modifies the necessary flag_bits entries accordingly. The ZIPfile format is simple enough that as long as you arenâ€™t changing the length of the file, you should find this fairly easy.
Or create a modified zipfile module of your own and use that instead. You could add an extra method, e.g. write_with_flags, so that your module would match the regular one for other code but provide extra control as required by you.
Many options on how to fix, I could do as you say, I could just copy the Py3 zipfile module, change it how I want, and include it with my project, I could monkey-patch, or I could just shrug my shoulders and carry on using Python 2.
Get the person who manufactures the zipfile to use Python 3 ğŸ™‚
Simon, I hope my comment doesnâ€™t sound snarkyâ€“I donâ€™t intend it that way.
Is this a common concern in something you do routinely?  If numerous dupes canâ€™t be de-duplicated prior to archival and network transferâ€¦ it seems to be a good opportunity for process improvement somewhere.  
If the assembly is out of your control (yet the transfer and subsequent care is on your shoulders), Iâ€™m sorryâ€“maybe it will help knowing I can relate a bit to that.
Hi Bryan, no it doesnâ€™t sound snarky in the slightest, and no I donâ€™t control my input, otherwise I wouldnâ€™t set the flag bits on the archive in the first place and Iâ€™d have no issue.
But I do find it odd that people are bending over backwards to excuse a perfectly reproducible bug in Python 3, as if itâ€™s the developer whoâ€™s somehow at fault here.  Granted you havenâ€™t said that explicitly, but itâ€™s certainly the way it comes across.  I do code in Python 3, and Iâ€™ve converted thousands of lines of code from 2 -> 3.  Iâ€™m completely on-board with the latest Python 3 developments, and Iâ€™m fixing my byte-string issues in seconds, the tools are picking up a lot of other stuff without me even having to run the code (thanks PyCharm), but Python 3 is not a religion for me, and itâ€™s a bit annoying when people chastise me for still having Python 2 code without understanding all the issues.  Much of the time is consumed trying to fix the third party modules that â€˜workâ€™ for Python 3, but fall down with their own edge-cases, because they only got a cursory Python 3 testing.
I feel for ya buddy. Â The niche cases rarely (never?) get attention. Â And drive-by testing sucks. :,(
Sorry Simon. Â No doubt it will cause waves, but hopefully youâ€™ll be able to get the upstream folks to use Python 3.
I have a few legacy systems at my current job whose handoff instructions to me were essentially, â€œkeep this breathing, we need it yet canâ€™t replace it.â€ Â Chrome will completely stop supporting Flash in Decemberâ€“a tidbit that no one should even know anymoreâ€“but I have a (strictly) internal system thatâ€™s no longer vendor-maintained and will be extremely expensive to replace. And yesâ€¦Flash.
Feel for ya buddy.
Speaking of niche casesâ€¦
At a job in 2009, I used the same Windows Explorer folders on a daily basis, migrating case files back & forth between folders named â€œcomplete,â€ â€œnotified,â€ â€œpending,â€ â€œresolved,â€ â€œdismissed.â€ Â I started the job still on WinXP, where individual folders could be positioned on my screen in a consistent, predictable, efficient array, and Explorer itself remembered each windowâ€™s size and position.  Itâ€™s a long habit of mine to UNcheck â€œhide extensions for known file typesâ€ as I check â€œrestore previous windows at logonâ€ and choose â€œdetailed listâ€ instead of icons.  We geeks like to know modification times and file sizesâ€“and sorting by either is often handy.
If the OS crashed, howeverâ€“the positions were lost, and I had to rearrange again. Â Not a huge effort, but it took a couple minutes I shouldâ€™ve spent actually working. Â I often thought Explorer should maintain an .xml file to track its windows, restoring upon recovery/startup. Â Milliseconds to update, it would save time for each user with a need like mine.
Wellâ€¦ it took me ages to admit my usage was non-standard to the point most non-power-users couldnâ€™t even fathom my explanationâ€“or at least would raise eyebrows at why I considered it a worthwhile lament, since describing the problem took longer than the fix did.
â€œFortunately,â€ my new Windows7 box stopped tracking window positions altogetherâ€“and instead decided to save settings based on â€œfolders of this type,â€ giving me something entirely new to complain about, for being audacious enough to still care about file size or mod time of â€œprettyâ€ files like images and audioâ€“where apparently all I really need is a thumbnail to violate my already-set preference for a detailed list.
> unpack a zip archive and re-pack it so it has the same checksum
Hahah, I was cutting my Unix/Linux teeth in mid-2000 when the game Quake III Arena was in full swing.  Id Software provided tools for player-created levels, which were simply .zip files rebranded with a .pk3 extension.
Buddies and I would stage LAN parties, exchanging user-contributed levels, numbering in the hundreds.  Weâ€™d scour the web for new custom maps, adding them to the hordeâ€“we spent many hours exploring, shooting, categorizing, ranking.
I took it upon myself to consolidate all these maps to a personal web server.  Wanting a convenient, centralized repository, I hosted the actual game files, despite that most would be available via the original links for years.
Iâ€™ve never claimed to be the smartest dude.
Weâ€™d switch maps at the command line, but recalling the names of all our favorite maps became increasingly cumbersome,â€  so I wrote a script to parse all the files weâ€™d downloaded and extract each levelâ€™s screenshot.  It built a new page to host links for the downloads, with all the images as a guide.
â€  Thunda3dm1, Charon3dm3, saiko_tourney1, ztn3dm1, Distonic, mvdm01â€¦
Anyway, my smug satisfaction with my accomplishment deflated when playing a few isolated games on public servers found us re-downloading maps we *knew* weâ€™d already acquired.  Turns out, in my zeal to streamline everythingâ€“including faster downloadsâ€“Iâ€™d re-packed every map with maximum compression, completely oblivious to how a public game server might strive to mitigate cheatersâ€“thereby using a checksum in that endeavor, ensuring everyone has the same map.
All my â€œefficientâ€ re-packs had checksums not recognized by anyone outside our circle of friends.  Every one of us had to download them again at 2.4KB/secâ€¦
Oops.  Iâ€™ve never claimed to be the smartest dude.
Comment * 
Name 
Email 
Website 
 



Î”