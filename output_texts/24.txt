Sophos Home protects every Mac and PC in your home 
Remember all those funkily named bugs of recent memory, such as Spectre, Meltdown, F**CKWIT and RAMbleed?
Very loosely speaking, these types of bug ‚Äì perhaps they‚Äôre better described as ‚Äúperformance costs‚Äù ‚Äì are a side effect of the ever-increasing demand for ever-faster CPUs, especially now that the average computer or mobile phone has multiple processor chips, typically with multiple cores, or processing subunits, built into each chip.
Back in the olden days (by which I mean the era of chips like the Inmos Transputer), received wisdom said that the best way to do what is known in the jargon as ‚Äúparallel computing‚Äù, where you split one big job into lots of smaller ones and work on them at the same time, was to have a large number of small and cheap processors that didn‚Äôt share any resources.
They each had their own memory chips, which means that they didn‚Äôt need to worry about hardware synchronisation when trying to dip into each others‚Äô memory or to peek into the state of each others‚Äô processor, because they couldn‚Äôt.
If job 1 wanted to hand over an intermediate result to job 2, some sort of dedicated communications channel was needed, and accidental interference by one CPU in the behaviour of another was therefore sidestepped entirely.
Transputer chips each had four serial data lines that allowed them to be wired up into a chain, mesh or web, and jobs had to be coded to fit the interconnection topology available.
This model was called share-nothing, and it was predicated on the idea that allowing multiple CPUs to share the same memory chips, especially if each CPU had its own local storage for cached copies of recently-used data, was such a complex problem in its own right that it would dominate the cost ‚Äì and crush the performance ‚Äì of share-everything parallel computing.
But share-everything computers turned out to much easier to program than share-nothing systems, and although they generally gave you a smaller number of processors, your computing power was just as good, or better, overall.
So share-everything was the direction in which price/performance and thus market ultimately went.
After all, if you really wanted to, you could always stitch together several share-everything parallel computers using share-nothing techniques ‚Äì by exchanging data over an inexpensive LAN, for example ‚Äì and get the best of both worlds.
However, as Spectre, Meltdown and friends keep reminding us, system hardware that allows separate programs on separate processor cores to share the same physical CPU and memory chips, yet without treading on each others‚Äô toes‚Ä¶
‚Ä¶may leave behind ghostly remains or telltales of how other progams recently behaved.
These spectral remnants can sometimes be used to figure out what other programs were actually doing, perhaps even revealing some of the data values they were working with, including secret information such as passwords or decryption keys.
And that‚Äôs the sort of glitch behind CVE-2022-0330, a Linux kernel bug in the Intel i915 graphics card driver that was patched last week.
Intel graphics cards are extremely common, either alone or alongside more specialised, higher-performance ‚Äúgamer-style‚Äù graphics cards, and many business computers running Linux will have the i915 driver loaded.
We can‚Äôt, and don‚Äôt really want to, think of a funky name for the CVE-2022-0330 vulnerability, so we‚Äôll just refer to it as the drm/i915 bug, because that‚Äôs the search string recommended for finding the patch in the latest Linux kernel changelogs.
To be honest, this probably isn‚Äôt a bug that will cause many people a big concern, given that an attacker who wanted to exploit it would already need:
Simply put, the bug involves a processor component known as the TLB, short for Translation Lookaside Buffer.
TLBs have been built into processors for decades, and they are there to improve performance.
Once the processor has worked out which physical memory chip is currently assigned to hold the contents of the data that a user‚Äôs program enumerates as, say, ‚Äúaddress #42‚Äù, the TLB lets the processor side-step the many repeated memory address calculations might otherwise be needed while a program was running in a loop, for example.
The reason regular programs refer to so-called virtual addresses, such as ‚Äú42‚Äù, and aren‚Äôt allowed to stuff data directly into specific storage cells on specific chips is to prevent security disasters. Anyone who coded in the glory days of 1970s home computers with versions of BASIC that allowed you to sidestep any memory controls in the system will know how catastrophic an aptly named but ineptly supplied POKE command could be.)
Apparently, if we have understood the drm/i915 bug correctly, it can be ‚Äútickled‚Äù in the following way:
At this point, even if the kernel maps User X‚Äôs second lot of GPU code onto a completely new, system-selected, chunk of memory, User X‚Äôs GPU code will still be accessing memory via the old TLB entries.
So some of User X‚Äôs memory accesses will inadvertently (or deliberately, if X is malevolent) read out data from a stale physical address that no longer belongs to User X.
That data could contain confidential data stored there by User Z, the new ‚Äúowner‚Äù of buffer Y.
So, User X might be able to sneak a peek at fragments of someone else‚Äôs data in real-time, and perhaps even write to some of that data behind the other person‚Äôs back.
Clearly, exploiting this bug for cyberattack purposes would be enormously complex.
But it is nevertheless a timely reminder that whenever security shortcuts are brought into play, such as having a TLB to sidestep the need to re-evaluate memory accesses and thus speed things up, security may be dangerously eroded.
The solution is simple: always invalidate, or flush, the TLB whenever a user finishes running a chunk of code on the GPU. (The previous code waited until someone else wanted to run new GPU code, but didn‚Äôt always check in time to suppress the possible access control bypass.)
This ensures that the GPU can‚Äôt be used as a ‚Äúspy probe‚Äù to PEEK unlawfully at data that some other program has confidently POKEd into what it assumes is its own, exclusive memory area.
Ironically, it looks as though the patch was originally coded back in October 2021, but not added to the Linux source code because of concerns that it might reduce performance, whilst fixing what felt at the time like a ‚Äúmisfeature‚Äù rather than an outright bug.
By the way, if you don‚Äôt need and haven‚Äôt loaded the i915 driver (and it isn‚Äôt compiled it into your kernel), then you aren‚Äôt affected by this bug because it‚Äôs specific to that code module.
Follow @NakedSecurity on Twitter for the latest computer security news.
Follow @NakedSecurity on Instagram for exclusive pics, gifs, vids and LOLs!
I just had a kernel update today, but I haven‚Äôt restarted the computer yet. Is today‚Äôs update affected?
What‚Äôs the version number? If your distro lags behind a bit then you might not have this fix yet‚Ä¶ if your distro tends to get the latest kernel version typically the same day (mine does) then today‚Äôs update could indeed be the latest.
Current Kernel is Linux 5.4.0-96-generic #109-Ubuntu SMP Wed Jan 12 16:49:16 UTC 2022
But anyways I ran the lsmod line and nothing showed up.
Thanks for your interesting and informative newsletters.
I have no idea how to read Ubuntu version numbers but the date of 2022-01-12 implies it‚Äôs well before the patches that fix this bug were published.
If you don‚Äôt have an Intel graphics card (I have a business-style laptop with all-Intel chipsettery, so I do).
Running ‚Äòlspci‚Äô should reveal your graphics card for confirmation.
Study, ‚ÄúAnti-Aliasing.‚Äù
Honestly, given the difficulty behind this, I‚Äôd just take the exploit. Even in my own house, I always lock my computer, and I have deny-all rules on by default on all my machines (meaning remote access is not available). Linux graphics performance is poor enough as is on less common machines, I‚Äôll look after my machine myself and accept the consequences of my decisions.
Besides that, there‚Äôs an age-old rule in computing: if you have gained physical access to the machine, it‚Äôs already as good as compromised. So ok, I‚Äôve patched my graphics card driver, and I‚Äôve locked my screen. Plug in a Bush Bunny, and I‚Äôm completely screwed, anyway.
Well, it‚Äôs not the only vuln patched lately so it‚Äôs worth updating anyway, but I thought it was the funkiest one and thus worth writing about‚Ä¶
We really need to expect ‚Äúformal logic‚Äù proofs of program ideas and implementations.  I have studied it, off and on, for decades; and I can say that humans implementing it, is excruciating!  Things like the Iron Maiden come to mind üôÇ
And a friend of mine thought that the specification problem was NP complete; but it‚Äôs basically required for verification.
But ‚Ä¶  look at where we are at.  Don‚Äôt we need better programs instead of an endless series of bugs/updates/malware?
Formal Program proving references
http://www.cs.cornell.edu/courses/cs312/2008sp/lectures/logic.html
https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/en-us-events-2013summerschool-nick-benton.pdf
Comment * 
Name 
Email 
Website 
 



Œî